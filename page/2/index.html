<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="基于hexo搭建的个人博客"><meta name="keywords" content="blog,liuarui"><meta name="author" content="liuarui"><meta name="copyright" content="liuarui"><title>@lm/blog | liuarui的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liuarui</div><div class="author-info__description text-center">基于hexo搭建的个人博客</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/liuarui">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">29</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">liuarui的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">liuarui的博客</div><div id="site-sub-title">@lm/blog</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/21/HTML/html/%E6%A0%87%E7%AD%BE/">HTML标签相关</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-21</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/HTML/">HTML</a></span><div class="content"><p><a href="./%E6%A0%87%E7%AD%BE.html">demo</a></p>
<h1 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h1><p>属性</p>
<ul>
<li><p>  <code>contend</code></p>
</li>
<li><p><code>http-equiv</code>[content-type | expires | refresh | set-cookie]</p>
<ul>
<li><p>  把 content 属性关联到 HTTP 头部。</p>
</li>
<li><p>  http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。</p>
</li>
<li><p>  当服务器向浏览器发送文档时，会先发送许多名称/值对。虽然有些服务器会发送许多这种名称/值对，但是所有服务器都至少要发送一个：content-type:text/html。这将告诉浏览器准备接受一个 HTML 文档。</p>
</li>
<li><p>  使用带有 http-equiv 属性的 <meta> 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;charset&quot;</span> <span class="attr">content</span>=<span class="string">&quot;iso-8859-1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;31 Dec 2008&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这样发送到浏览器的头部就应该包含：</span><br><span class="line">content-type: text/html</span><br><span class="line">charset:iso-8859-1</span><br><span class="line">expires:31 Dec 2008</span><br><span class="line">当然，只有浏览器可以接受这些附加的头部字段，并能以适当的方式使用它们时，这些字段才有意义。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>name</code><br>  可选值<ul>
<li>  author</li>
<li>  description</li>
<li>  keywords</li>
<li>  generator</li>
<li>  revised</li>
<li>  others</li>
</ul>
</li>
<li><code>scheme</code><br>  定义用于翻译 content 属性值的格式。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">contend</span>=<span class="string">&quot;关键词1,关键词2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="script"><a href="#script" class="headerlink" title="script"></a>script</h1><ul>
<li><code>async </code><ul>
<li>  无顺序，谁先加载完成谁先执行</li>
</ul>
</li>
<li><code>defer</code><ul>
<li>  启动一个新线程去下载，然后在<code>DOMContentLoaded</code>事件执行前执行脚本</li>
<li>  多个按先后顺序</li>
</ul>
</li>
</ul>
<h1 id="link"><a href="#link" class="headerlink" title="link"></a>link</h1><ul>
<li>  <code>prefetch</code></li>
<li>  <code>prerender</code></li>
<li>  <code>preload</code></li>
</ul>
<h1 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h1><ul>
<li>  canvas API</li>
<li>  webGL API</li>
</ul>
<h1 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h1><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/SVG">https://developer.mozilla.org/zh-CN/docs/Web/SVG</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/01/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/Why%20I%20use%20Tape%20Instead%20of%20Mocha%20&amp;%20So%20Should%20You/">Why I use Tape Instead of Mocha &amp; So Should You</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E7%BF%BB%E8%AF%91/">单元测试 翻译</a></span><div class="content"><h1 id="Why-I-use-Tape-Instead-of-Mocha-amp-So-Should-You"><a href="#Why-I-use-Tape-Instead-of-Mocha-amp-So-Should-You" class="headerlink" title="Why I use Tape Instead of Mocha &amp; So Should You"></a>Why I use Tape Instead of Mocha &amp; So Should You</h1><h1 id="为什么我要使用-Tape-来替代-Mocha-amp-你也应该这么评估软件质量"><a href="#为什么我要使用-Tape-来替代-Mocha-amp-你也应该这么评估软件质量" class="headerlink" title="为什么我要使用 Tape 来替代 Mocha &amp; 你也应该这么评估软件质量"></a>为什么我要使用 Tape 来替代 Mocha &amp; 你也应该这么评估软件质量</h1><p>作者<a target="_blank" rel="noopener" href="https://medium.com/@_ericelliott?source=post_page-----6aa105d8eaf4--------------------------------">Eric Elliott</a></p>
<p>写作时间：Jul 13, 2015</p>
<blockquote>
<p><em>TL;DR: Mocha is a $150k Porsche Panamera when the best tool for the job is a $30k Tesla Model 3. Don’t waste your resources on testing bells and whistles. Invest them in creating your app, instead.</em> &gt;<em>总结: Mocha 是一个价值 150 刀的保时捷，但是往往我们工作中只需要 30 刀的特斯拉就能带来最好的效益。不要为了使用一个测试软件而去使用测试软件，而是使用他们来驱动你的程序开发。</em><br>UPDATE: I have written a simplified wrapper around Tape to make it even simpler to write great unit tests which provide clear bug reports when they fail. See <a target="_blank" rel="noopener" href="https://medium.com/javascript-scene/rethinking-unit-test-assertions-55f59358253f">“Rethinking Unit Test Assertions”</a> for more details.<br>UPDATE：我对 Tape 进行了简易封装，使它能够更容易的编写出优秀的单元测试，且能够在测试用例未通过时提供清晰的错误报告，有关其更多信息请参考 <a target="_blank" rel="noopener" href="https://medium.com/javascript-scene/rethinking-unit-test-assertions-55f59358253f">“Rethinking Unit Test Assertions”</a></p>
</blockquote>
<p>Sometimes popularity is an indication of quality. Other times, popular things are popular for popularity’s sake, and not because they’re better than alternatives.</p>
<p>一般而言，受欢迎程度反映了事物的质量。但有时，受欢迎的事物只是因为受欢迎而受欢迎，而不是因为它们比非主流的更好。</p>
<p>On real production projects, I have used Jasmine, Mocha, NodeUnit, Tape, and a bunch of other solutions. I have investigated <em>many other options.</em> For the last few years, I have used and continue to use <a target="_blank" rel="noopener" href="https://github.com/substack/tape">Tape</a> along with Supertest (for API testing) on all of my personal projects and projects that I lead.</p>
<p>在实际的生产项目中，我曾使用过 Jasmine，Mocha，NodeUnit，Tape 和许多其他解决方案。我研究过各种框架。但是在过去的几年中，我在我所有的个人项目和我主导的项目中都使用并继续使用<a target="_blank" rel="noopener" href="https://github.com/substack/tape">Tape</a>和 Supertest（用于 API 测试）。</p>
<h2 id="What-are-Unit-tests"><a href="#What-are-Unit-tests" class="headerlink" title="What are Unit tests?"></a>What are Unit tests?</h2><h2 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h2><p>Unit tests exist to test individual units of software functionality. A unit is a module, component, or function. They’re bits of the program that can work independently of the rest of the program. The presence of unit testing implies that the software is designed in a modular fashion. You may hear once in a while that there are ways to make software “more testable.”</p>
<p>单元测试常见于测试软件功能的各个单元。单元是可以是一个模块，组件或函数。它们是程序的一部分，可以独立于程序的其余部分工作。单元测试的存在意味着该软件是以模块化方式设计的。您可能偶尔会听到有一些使软件“更具可测试性”的方法。</p>
<p>If you find that it’s hard to write unit tests for your program without mocking lots of other things, that’s a sign that your program is not modular enough. Revealing tight coupling (the opposite of modularity) is one of the many important roles that unit tests play in software creation.</p>
<p>如果您发现很难在不模拟许多其他事情的情况下为程序编写单元测试，则表明您的程序不够模块化。发现耦合（与模块化相反）是单元测试在软件开发中扮演的许多重要功能之一。</p>
<p>Every module should have unit tests, and every application should be made up of modules. In other words, if you’re not writing unit tests, you should be.</p>
<p>每个模块都应该有单元测试，每个应用程序都应该由模块组成。换句话说，如果您不编写单元测试，则更应该这么做。</p>
<h2 id="What’s-Wrong-with-Mocha-Jasmine-etc…"><a href="#What’s-Wrong-with-Mocha-Jasmine-etc…" class="headerlink" title="What’s Wrong with Mocha, Jasmine, etc…?"></a>What’s Wrong with Mocha, Jasmine, etc…?</h2><h2 id="Mocha，Jasmine-等框架都存在什么问题？"><a href="#Mocha，Jasmine-等框架都存在什么问题？" class="headerlink" title="Mocha，Jasmine 等框架都存在什么问题？"></a>Mocha，Jasmine 等框架都存在什么问题？</h2><ol>
<li><p><strong>Too much configuration :</strong> Choose an assertion library, chose a reporting library, chose a task runner (Grunt, Gulp, etc…) Then figure out how to translate the documentation examples to the reporting library / task runner you chose. All of this is too much cognitive load. Vs: Choose Tape. Done.</p>
</li>
<li><p>**Globals: **Mocha, Jasmine, and several other alternatives pollute the global environment with functions like <code>describe</code>, <code>it</code>, etc… Some assertion libraries extend built-in prototypes. Aside from removing the self-documenting nature of simple module exports, those decisions could potentially conflict with the code you’re trying to test. Vs: Tape’s simple module export.</p>
</li>
<li><p><strong>Shared State:</strong> Functions like <em><code>beforeEach</code></em> and <em><code>afterEach</code></em> actively encourage you to do something you <strong>definitely should not do</strong>: Share state between tests. <em>Vs. Tape: No such functions for global state sharing. Instead, call setup and teardown routines from individual tests, and</em> <strong>*contain all state to local test variables.*</strong></p>
</li>
<li><p><strong>过多的配置项：</strong>选择一个断言库，选择一个报告库，选择一个任务组织器 (Grunt, Gulp, etc…)，然后还得学习你所选择的报告库和任务组织器的文档示例，学习成本过高。相比之下：选择使用 Tape，完事～</p>
</li>
<li><p><strong>全局变量：</strong>Mocha，Jasmine 等等通过<code>describe</code>，<code>it</code>等全局函数污染全局环境。某些断言库扩展了内置原型。除了破坏了模块的纯净性以外，这些操作还可能与您要测试的代码冲突。相比下：Tape 的纯净模块导出。</p>
</li>
<li><p><strong>共享状态：</strong>诸如*<code>beforeEach</code><em>和</em><code>afterEach</code>之类的功能*积极地鼓励您做一些您<strong>绝对不应该做的事情</strong>：在测试之间共享状态。相比下： Tape 没有用于全局状态共享的此类功能。取而代之的是，从制定的测试用例中调用挂载和卸载，并将所有状态包含在本地测试变量中。</p>
</li>
</ol>
<h2 id="Why-Tape"><a href="#Why-Tape" class="headerlink" title="Why Tape?"></a>Why Tape?</h2><h2 id="为什么选择-Tape？"><a href="#为什么选择-Tape？" class="headerlink" title="为什么选择 Tape？"></a>为什么选择 Tape？</h2><p>Mocha does way too much and gives developers way too many assertion choices, and that leads to <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Analysis_paralysis">analysis paralysis</a> and lost productivity. Every time I have seen Mocha used on a project, I’ve seen developers dump way too much time in the testing framework and testing environment.</p>
<p>Mocha 给了开发者太多的断言库选择，这导致<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Analysis_paralysis">分析瘫痪</a>和降低了生产效率。每当 Mocha 在项目中使用时，我都看到开发人员搭建在测试框架和测试环境过程中浪费了太多时间。</p>
<p>While I’m ranting I would be remiss if I didn’t mention that if you spend a lot of time on mocks and stubs, that’s a strong code-smell. You can probably dramatically simplify both your tests and your application by breaking your app into more modular chunks.</p>
<p>我很想告诉你，如果您在 mocks 和 stubs 上花费大量时间，那说明你跑偏了，这是一种很糟糕的事情。因为往往将应用程序划分为更多的模块，您就能过极大地简化测试和应用程序。</p>
<h2 id="Mocking-is-a-code-smell"><a href="#Mocking-is-a-code-smell" class="headerlink" title="Mocking is a code smell."></a>Mocking is a code smell.</h2><h2 id="过重的-Mock-是一中糟糕的编码习惯"><a href="#过重的-Mock-是一中糟糕的编码习惯" class="headerlink" title="过重的 Mock 是一中糟糕的编码习惯"></a>过重的 Mock 是一中糟糕的编码习惯</h2><p>A few simple mocks here and there are OK. Some of your app will inevitably involve side-effects (reading from or writing to the network or filesystem, for instance). When you do have a genuine need for mocks, keep them simple. Little more than basic stubs are ideal. But on many projects, I’ve seen a lot of over-complicated mocks that never needed to exist in the first place. Why maintain more code than you need to?<br>The more you break your problems down into simple, pure functions, the easier it will be to test your code without mocks.<br>一些简单的 Mocking 可以接受。部分情况下，您的某些应用程序不可避免地会被带入副作用（例如，从网络或文件系统读取或写入网络或文件系统）。当您确实需要 Mock 时，请尽量使其简单。采用更多基础 stubs 是不错的主意。但是在许多项目中，我看到了很多过于复杂的 Mock，这些 Mock 从一开始就不需要存在。为什么要维护比您所需更多的代码？<br>将问题分解成简单的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pure_function">纯</a> <a target="_blank" rel="noopener" href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4">函数</a>的次数越多，_无需 Mock 就可以测试代码_。</p>
<h2 id="Testing-is-not-what-you-should-spend-most-of-your-time-doing"><a href="#Testing-is-not-what-you-should-spend-most-of-your-time-doing" class="headerlink" title="Testing is not what you should spend most of your time doing."></a>Testing is not what you should spend most of your time doing.</h2><h2 id="你不应该投入大量时间去编写测试用例"><a href="#你不应该投入大量时间去编写测试用例" class="headerlink" title="你不应该投入大量时间去编写测试用例"></a>你不应该投入大量时间去编写测试用例</h2><p>You should spend most of your time thinking about how to create the best, most flexible, most performant solutions given the afforded time constraints. Time is value in the software development world, and you shouldn’t waste one minute of it.</p>
<p>在有限时间的开发周期内下，您应将大部分时间都花在如何创建更好，更灵活，更高性能的解决方案上。在软件开发世界中，时间很重要，您不应该浪费时间。</p>
<p>If you get your kicks burning money, use Mocha, Jasmine, Jest, etc… But if you value your time, keep reading.</p>
<p>如果并无所谓，可以使用 Mocha，Jasmine，Jest 等。但是，如果您珍惜你的时间，请继续阅读。</p>
<p>With many BDD assertion libraries, there are getters with side effects. At one company I worked for (not naming names), that buried a bug in one of our tests, and we spent far too long debugging the test case rather than developing actual application code.</p>
<p>在许多 BDD 断言库中，他们都有些带有副作用的 getters。在我工作的一家公司（没有命名），这在我们的一个测试中掩埋了一个错误，并且我们花了太多的时间调试测试用例，而不是开发实际的应用程序代码。</p>
<h2 id="Test-assertions-should-be-dead-simple-amp-completely-free-of-magic"><a href="#Test-assertions-should-be-dead-simple-amp-completely-free-of-magic" class="headerlink" title="Test assertions should be dead simple,&amp; completely free of magic."></a>Test assertions should be dead simple,&amp; <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Magic_(programming)">completely free of magic</a>.</h2><h2 id="测试断言应该尽可能的简单，并且完全没有黑魔法（不带入除应有实现的实现）"><a href="#测试断言应该尽可能的简单，并且完全没有黑魔法（不带入除应有实现的实现）" class="headerlink" title="测试断言应该尽可能的简单，并且完全没有黑魔法（不带入除应有实现的实现）"></a>测试断言应该尽可能的简单，并且完全没有黑魔法（不带入除应有实现的实现）</h2><p><em><code>equal</code></em>, <em><code>deepEqual</code></em>, <em><code>pass</code></em> &amp; <em><code>fail</code></em> are my primary go-to assertions. If <em><code>equal</code></em> and <em><code>deepEqual</code></em> were the only assertions available anywhere, the testing world would probably be better off for it.</p>
<p>Why? <em><code>equal</code></em> &amp; <em><code>deepEqual</code></em> provide quality information about expectations, and they lead to very concise test cases that are <strong>easy to read &amp; maintain.</strong></p>
<p>When you write a bug report, you should always <em>provide a description,</em> explain <em>what you expected to see</em>, and explain <em>what you actually saw</em>.</p>
<p>Test cases should be written in much the same way:</p>
<ol>
<li>Describe the feature that you’re testing in plain English.</li>
<li>Provide the expected outcome of the test. This part is why many unit tests are called <em>expectations.</em></li>
<li>Compare that to the <em>actual value.</em></li>
</ol>
<p>When a unit tests fails, <em>the error message is your bug report.</em></p>
<p><em><code>equal</code></em>, <em><code>deepEqual</code></em>, <em><code>pass</code></em> &amp; <em><code>fail</code></em> 是我常用的断言。如果*<code>equal</code>* and <em><code>deepEqual</code></em> 是唯一可用的断言，那么测试可读性会变得更好。</p>
<p>为什么？_<code>equal</code>_ &amp; <em><code>deepEqual</code></em> 提供有关期望的质量信息，它们测试用例使非常简洁，<strong>易于阅读和维护。</strong></p>
<p>编写错误报告时，应始终<em>提供说明，</em>解释<em>您期望看到的内容</em>，并解释<em>您实际看到的内容</em>。</p>
<p>测试用例的编写方式一般参见如下：</p>
<ol>
<li>用简单的英语描述您要测试的功能。</li>
<li>提供测试的预期结果。这就是为什么许多单元测试称为<em>期望的原因。</em></li>
<li>将其与<em>实际值</em>进行比较<em>。</em></li>
</ol>
<p>当单元测试失败时，<em>错误消息就是您的错误报告。</em></p>
<h2 id="Your-test-descriptions-should-be-clear-enough-to-use-as-documentation"><a href="#Your-test-descriptions-should-be-clear-enough-to-use-as-documentation" class="headerlink" title="Your test descriptions should be clear enough to use as documentation."></a>Your test descriptions should be clear enough to use as documentation.</h2><h2 id="您的测试描述应足够清晰，以至可以当作文档阅读。"><a href="#您的测试描述应足够清晰，以至可以当作文档阅读。" class="headerlink" title="您的测试描述应足够清晰，以至可以当作文档阅读。"></a>您的测试描述应足够清晰，以至可以当作文档阅读。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;tape&#x27;</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;A passing test&#x27;</span>, <span class="function">(<span class="params">assert</span>) =&gt;</span> &#123;</span><br><span class="line">    assert.pass(<span class="string">&#x27;This test will pass.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    assert.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;Assertions with tape.&#x27;</span>, <span class="function">(<span class="params">assert</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> expected = <span class="string">&#x27;something to test&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> actual = <span class="string">&#x27;sonething to test&#x27;</span></span><br><span class="line"></span><br><span class="line">    assert.equal(</span><br><span class="line">        actual,</span><br><span class="line">        expected,</span><br><span class="line">        <span class="string">&#x27;Given two mismatched values, .equal() should produce a nice bug report&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    assert.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>If you write tests this way, your test error messages should be clear enough to use as bug reports:</p>
<p>如果你这么写测试用例，则你的测试错误信息将会足够清楚，甚至用来当作 bug 报告来看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TAP version 13</span><br><span class="line"><span class="meta">#</span><span class="bash"> A passing <span class="built_in">test</span></span></span><br><span class="line">ok 1 This test will pass.</span><br><span class="line"><span class="meta">#</span><span class="bash"> Assertions with tape.</span></span><br><span class="line">not ok 2 Given two mismatched values, .equal() should produce a nice bug report</span><br><span class="line">  ---</span><br><span class="line">    operator: equal</span><br><span class="line">    expected: &#x27;something to test&#x27;</span><br><span class="line">    actual:   &#x27;sonething to test&#x27;</span><br><span class="line">  ...1..2</span><br><span class="line"><span class="meta">#</span><span class="bash"> tests 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pass 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fail 1</span></span><br></pre></td></tr></table></figure>

<h2 id="Your-automated-test-error-messages-are-your-bug-reports"><a href="#Your-automated-test-error-messages-are-your-bug-reports" class="headerlink" title="Your automated test error messages are your bug reports."></a>Your automated test error messages are your bug reports.</h2><h2 id="您的自动测试错误消息就是您的错误报告。"><a href="#您的自动测试错误消息就是您的错误报告。" class="headerlink" title="您的自动测试错误消息就是您的错误报告。"></a>您的自动测试错误消息就是您的错误报告。</h2><p>Simple tests assertions provide:</p>
<ul>
<li>  Better readability.</li>
<li>  Less code.</li>
<li>  Less maintenance.</li>
</ul>
<p>These features trump all the bells and whistles in the world.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">进程与线程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">操作系统 计算机基础</a></span><div class="content"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>一个正在执行的程序实例对应一个进程</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>4 个主要事件会导致进程的创建</p>
<ul>
<li>  系统初始化</li>
<li>  正在运行的程序执行创建进程的系统调用</li>
<li>  用户请求创建一个新进程</li>
<li>  一个批处理作业的初始化</li>
</ul>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><ul>
<li>  正常退出 自愿</li>
<li>  出错退出 自愿</li>
<li>  严重错误 非自愿</li>
<li>  被其他进程杀死 非自愿</li>
</ul>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul>
<li><p>  运行态</p>
</li>
<li><p>  就绪态</p>
</li>
<li><p>  阻塞态</p>
</li>
<li><p>  <img src="./img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="进程状态"></p>
</li>
</ul>
<ol>
<li>进程阻塞</li>
<li>2、3 进程调度</li>
<li>进程等待时发生外部事件</li>
</ol>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>  进程表</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/">操作系统概念</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">操作系统 计算机基础</a></span><div class="content"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>用户态</p>
<p>内核态</p>
<p>多路复用</p>
<ul>
<li>  时间复用</li>
<li>  空间复用</li>
</ul>
<p>操作系统决定何时分配资源</p>
<p>操作系统决定如何分配资源</p>
<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><ul>
<li>  寄存器</li>
<li>  流水线：执行指令的机制</li>
<li>  陷阱：将用户态转化为内核态，并将控制权交给操作系统</li>
<li>  多线程不是真正的并行，而是一个时刻只有一个进程在运行，但是线程的切换时间减少到纳秒数量级</li>
</ul>
<h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><ul>
<li>  寄存器</li>
<li>  高速缓存</li>
<li>  主存 RAM</li>
<li>  磁盘</li>
</ul>
<h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><ul>
<li>  中断</li>
<li>  中断优先级</li>
</ul>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>正在执行的一个程序</p>
<ul>
<li>  子进程</li>
<li>  进程树</li>
<li>  进程间通信</li>
</ul>
<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>  文件</li>
<li>目录<ul>
<li>  工作目录</li>
<li>  根目录</li>
</ul>
</li>
</ul>
<h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h4><p>一种虚文件，链接两个进程</p>
<h4 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h4><ul>
<li>  9 位二进制保护码，所有者、同组者、其他人</li>
<li>  rwx 位，读、写、执行</li>
</ul>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li>  POSIX 可移植操作系统接口</li>
<li>  PID 进程标识符</li>
<li>  fork 派生</li>
</ul>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>六种典型设计模式</p>
<ul>
<li><p>  单体系统</p>
</li>
<li><p>  层次式系统</p>
</li>
<li><p>  微内核</p>
</li>
<li><p>  客户端-服务器模式</p>
</li>
<li><p>  虚拟机</p>
</li>
<li><p>  外核</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/20/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a></span><div class="content"><h2 id="Test-Doubles-理解"><a href="#Test-Doubles-理解" class="headerlink" title="Test Doubles 理解"></a>Test Doubles 理解</h2><p>自动化测试中，我们常会使用一些经过<strong>简化</strong>的，行为与表现<strong>类似于生产环境下</strong>的对象的复制品。<br>引入这样的复制品能够降低构建测试用例的复杂度，允许我们独立而解耦地测试某个模块，不再担心受到系统中其他部分的影响；<br>这类型对象也就是所谓的 Test Double。</p>
<h3 id="Fakes"><a href="#Fakes" class="headerlink" title="Fakes"></a>Fakes</h3><ul>
<li>  Fake 是那些包含了生产环境下具体实现的简化版本的对象。</li>
</ul>
<h3 id="Stubs"><a href="#Stubs" class="headerlink" title="Stubs"></a>Stubs</h3><ul>
<li>  Stub 代指那些包含了预定义好的数据并且在测试时返回给调用者的对象。</li>
<li>  Stub 常被用于我们不希望返回真实数据或者造成其他副作用的场景。</li>
</ul>
<h4 id="command-query-separation"><a href="#command-query-separation" class="headerlink" title="command query separation"></a>command query separation</h4><p>query 只是查询，无副作用，不改变状态 ： Stubs<br>command 操作的同时会改变状态 ： Mocks</p>
<h3 id="Mocks"><a href="#Mocks" class="headerlink" title="Mocks"></a>Mocks</h3><blockquote>
<p>参考文章<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009443132">https://segmentfault.com/a/1190000009443132</a> &gt; <a target="_blank" rel="noopener" href="http://xunitpatterns.com/Test%20Double.html">http://xunitpatterns.com/Test%20Double.html</a> &gt; <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/mocksArentStubs.html">https://martinfowler.com/articles/mocksArentStubs.html</a></p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>  减少不必要的测试细节</li>
<li>  关注用户想要什么，就尽可能去测试什么</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/20/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E5%85%83%E7%BC%96%E7%A8%8B/">元编程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">编程范式</a></span><div class="content"><h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>  只要是与编程相关的编程就算是 meta-programming「元编程」</p>
</li>
<li><p>简单解释<br>  比如，若编程甲可以输出 A - Z，那么写程序甲算「编程」；<br>  而程序乙可以生成程序甲（也许还会连带着运行它输出 A - Z），那么编写程序乙的活动，就可以算作 meta-programming，「元编程」。</p>
</li>
<li><p>元编程常用来实现 DSL</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23856985">参考资料</a></p>
</blockquote>
</li>
</ul>
<h1 id="DSL-特定领域语言"><a href="#DSL-特定领域语言" class="headerlink" title="DSL(特定领域语言)"></a>DSL(特定领域语言)</h1><h2 id="外部-DSL"><a href="#外部-DSL" class="headerlink" title="外部 DSL"></a>外部 DSL</h2><ul>
<li>  通过解析器、babel 等编译工具实现特定语法 or 功能</li>
<li>  如 jsx</li>
</ul>
<h2 id="内部-DSL"><a href="#内部-DSL" class="headerlink" title="内部 DSL"></a>内部 DSL</h2><ul>
<li>  通过组合语言本身功能实现特定语法 or 功能</li>
<li>  如 jquery</li>
<li>  大部分实现方式使用级联、嵌套</li>
</ul>
<h2 id="JavaScript-中-DSL-实现"><a href="#JavaScript-中-DSL-实现" class="headerlink" title="JavaScript 中 DSL 实现"></a>JavaScript 中 DSL 实现</h2><p>easy: 使用 proxy</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107947462">参考资料</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/20/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">编程范式</a></span><div class="content"><h1 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h1><p>三大类</p>
<ul>
<li>  命令式 （过程式编程）</li>
<li>  声明式 （函数式编程）</li>
<li>  元编程 （面向对象编程）</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/woqutechteam/article/details/88101001">参考资料</a></p>
</blockquote>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>特点：</p>
<ul>
<li>函数是一等公民<br>  函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li>
<li>无副作用<br>  函数内部与外部互动，不要产生运算以外的其他结果<br>  引出了纯函数概念</li>
<li>不保存状态<br>  状态使用参数带入</li>
</ul>
<h1 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h1><p>TODO</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>参数为函数或返回值为函数的函数</p>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><blockquote>
<p>什么是函数式编程思维？ - 用心阁的回答 - 知乎<br>参考资料: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28292740/answer/40336090">https://www.zhihu.com/question/28292740/answer/40336090</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/20/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%BF%B5/">设计模式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">编程范式</a></span><div class="content"><p>找出程序中变化的地方，并将变化封装起来</p>
<p>重要的是模式的意图，而不是程序的结构</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果</p>
<p>把不变的抽离，可变的封装</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>目的；将信息隐藏</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/06/%E5%88%9D%E5%85%A5%E5%89%8D%E7%AB%AF/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">vue学习笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-06</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%B5%B7%E6%AD%A5/">起步</a></span><div class="content"><h4 id="ES6-中字符串的新方法"><a href="#ES6-中字符串的新方法" class="headerlink" title="ES6 中字符串的新方法"></a>ES6 中字符串的新方法</h4><p>给字符串补足位数</p>
<p>padStart（2，’0’）</p>
<p>padEnd（，’’）</p>
<h1 id="vue-指令"><a href="#vue-指令" class="headerlink" title="vue 指令"></a>vue 指令</h1><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p><code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code> 。</p>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
<p><strong><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</strong></p>
<p><code>v-model</code> 在内部使用不同的属性为不同的输入元素并抛出不同的事件：</p>
<ul>
<li>  text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li>
<li>  checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li>
<li>  select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<p><strong>对于需要使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E6%B3%95">输入法</a> (如中文、日文、韩文等) 的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 <code>input</code> 事件。</strong></p>
<h4 id="VUE-自定义指令的方法"><a href="#VUE-自定义指令的方法" class="headerlink" title="VUE 自定义指令的方法"></a>VUE 自定义指令的方法</h4><p>Vue 中所有的指令在调用时，都以 v-开头</p>
<h5 id="全局定义"><a href="#全局定义" class="headerlink" title="全局定义"></a>全局定义</h5><p>方法：</p>
<p><strong>参数 1：指令名称，定义时指令名称不需要加 v-，调用时才加上</strong></p>
<p><strong>参数 2：是一个对象，对象身上有指令相关的函数，函数在特定阶段执行相关操作</strong></p>
<p>钩子函数内的参数，（</p>
<blockquote>
<p>第一个为 el，原生 dom 对象,</p>
<p>第二个为指令传入的参数如：v-focus(200) ）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">bind</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//当指令绑定元素上，执行bind函数，只执行一次</span></span><br><span class="line">        <span class="comment">// el.focus()  无效，因为此时dom还没有解析完成，绑定先行</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">inserted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//当元素插入DOM中时，执行该函数，只触发一次</span></span><br><span class="line">        el.focus() <span class="comment">//插入dom时调用</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">updated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//当Vnode更新时，执行updated ，可能触发多次</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="私有定义"><a href="#私有定义" class="headerlink" title="私有定义"></a>私有定义</h5><p>在实例中直接添加 directives 对象即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directives:　&#123;</span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;fontweight&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">bind</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">            el.style.fontWeight = bingding.value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">inserted</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el,b</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="简写方式"><a href="#简写方式" class="headerlink" title="简写方式"></a>简写方式</h5><p>如果只需要对 bing 和 update 钩子，可以简写如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directives:　&#123;<span class="comment">//等同于同时写了bind和updated两个钩子</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;fontsize&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">            el.style.fontsize = <span class="built_in">parseInt</span>(binding.value)+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h4 id="变异方法和非变异方法"><a href="#变异方法和非变异方法" class="headerlink" title="变异方法和非变异方法"></a>变异方法和非变异方法</h4><p>变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。</p>
<p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</p>
<ul>
<li>  <code>push()</code></li>
<li>  <code>pop()</code></li>
<li>  <code>shift()</code></li>
<li>  <code>unshift()</code></li>
<li>  <code>splice()</code></li>
<li>  <code>sort()</code></li>
<li>  <code>reverse()</code></li>
</ul>
<p>相比之下，也有非变异 (non-mutating method) 方法，例如：<code>filter()</code>, <code>concat()</code> 和 <code>slice()</code> 。这些不会改变原始数组，但<strong>总是返回一个新数组</strong>。当使用非变异方法时，可以用新数组替换旧数组：</p>
<h1 id="VUE-实例的生命周期"><a href="#VUE-实例的生命周期" class="headerlink" title="VUE 实例的生命周期"></a>VUE 实例的生命周期</h1><h5 id="主要的生命周期函数分类："><a href="#主要的生命周期函数分类：" class="headerlink" title="主要的生命周期函数分类："></a>主要的生命周期函数分类：<img src="C:\Users\92530\Desktop\vue\lifecycle.png" alt="lifecycle"></h5><h6 id="1-创建期间的生命周期函数："><a href="#1-创建期间的生命周期函数：" class="headerlink" title="1.创建期间的生命周期函数："></a>1.创建期间的生命周期函数：</h6><ul>
<li>  beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li>
<li>  created：实例已经在内存中创建 OK，此时 data 和 methods 已经创建 OK，此时还没有开始 编译模板</li>
<li>  beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li>  mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ul>
<h6 id="2-运行期间的生命周期函数："><a href="#2-运行期间的生命周期函数：" class="headerlink" title="2.运行期间的生命周期函数："></a><strong>2.运行期间的生命周期函数：</strong></h6><ul>
<li>  beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染 DOM 节点</li>
<li>  updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ul>
<h6 id="3-销毁期间的生命周期函数："><a href="#3-销毁期间的生命周期函数：" class="headerlink" title="3.销毁期间的生命周期函数："></a><strong>3.销毁期间的生命周期函数：</strong></h6><ul>
<li>  beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>  destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<h1 id="VUE-组件"><a href="#VUE-组件" class="headerlink" title="VUE 组件"></a>VUE 组件</h1><h4 id="模块化和组件化的区别"><a href="#模块化和组件化的区别" class="headerlink" title="模块化和组件化的区别"></a>模块化和组件化的区别</h4><p>模块化：从代码逻辑的角度进行划分；方便代码分层开发，保证每个功能模块的职能单一</p>
<p>组件化：从 UI 界面的角度进行划分；前端的组件化方便 UI 组件的重用</p>
<p>VUE 组件：为了拆分 Vue 实例的代码量，能够以不同的组件，来划分不同的功能模块</p>
<p>组件有的都是 vue 实例有的，<strong>除了仅有的例外是像 <code>el</code>这样根实例特有的选项。</strong></p>
<h4 id="6-Vue-组件化创建方式"><a href="#6-Vue-组件化创建方式" class="headerlink" title="6.Vue 组件化创建方式"></a>6.Vue 组件化创建方式</h4><p><strong>每个组件必须只有一个根元素</strong></p>
<h5 id="1-全局组件"><a href="#1-全局组件" class="headerlink" title="1.全局组件"></a>1.全局组件</h5><p>1.第一种</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;组件名称&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;这里放标签&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第二种（字面量类型的模板组件）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;组件名称&#x27;</span>,&#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">template</span>:  ‘#这里放id’</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在实例控制区域之外定义 template 标签，直接在里面写结构</p>
<p>使用方法都是直接：&lt;组件名称&gt;&lt;/组件名称&gt;</p>
<p>注意：<strong>这里的组件名称如果使用驼峰命名法的话，那么在 html 结构中要使用-分隔开，而不能使用驼峰</strong></p>
<h5 id="2-私有组件"><a href="#2-私有组件" class="headerlink" title="2.私有组件"></a>2.私有组件</h5><p>components 属性定义内部私有组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">	<span class="string">&#x27;com1&#x27;</span>:&#123;</span><br><span class="line">		template：<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-组件中的-data-属性"><a href="#7-组件中的-data-属性" class="headerlink" title="7.组件中的 data 属性"></a>7.组件中的 data 属性</h4><p>组件里的 data 要定义为一个函数，且函数要返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以简写为</span></span><br><span class="line">	<span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>使用方法和实例中的是一样的</p>
<p><strong>问：为什么组件中的 data 必须是一个函数呢？</strong></p>
<p>​ 为了不让复用的组件之间的数据相互影响，所以使用函数来创建，且返回一个内部对象，这样子每次创建一个复用的组件时，之间的数据是相互独立的。</p>
<h4 id="8-组件切换（常用）"><a href="#8-组件切换（常用）" class="headerlink" title="8.组件切换（常用）"></a>8.组件切换（常用）</h4><p>如登陆和注册窗口场景</p>
<p>方法 1：使用 v-if 属性和 v-else 属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">login</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">register</span> <span class="attr">v-else</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">register</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;login&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;登录组件&lt;/h3&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;register&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;注册组件&lt;/h3&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">flag</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法 2：使用 component 标签的 is 属性</p>
<p>定义一个变量名 comName，用注册点击事件来更改展示组件的名称</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;comName=&#x27;login&#x27;&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;comName=&#x27;register&#x27;&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> *<span class="attr">:is</span>*=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="9-组件传值"><a href="#9-组件传值" class="headerlink" title="9.组件传值"></a>9.组件传值</h4><h5 id="1-父组件向子组件传值（传递数据）"><a href="#1-父组件向子组件传值（传递数据）" class="headerlink" title="1.父组件向子组件传值（传递数据）"></a>1.父组件向子组件传值（传递数据）</h5><p>默认情况下子组件无法直接访问父组件中的 data 数据和 methods 方法</p>
<p>通过属性绑定的形式 v-bind 自定义属性可以传递给子属性</p>
<p><strong>props 属性是唯一一个数组类型的，专门用来存储父组件传递来的数据，且该数据是只读的，无法重新赋值，</strong></p>
<p><strong>实际可修改，但是会报错</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com1</span> <span class="attr">v-bind</span>：<span class="attr">parentmsg</span>=<span class="string">&quot;“msg”&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--子组件定义 --&gt;</span></span><br><span class="line">com1: &#123; template: &#x27;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#x27; , props:</span><br><span class="line">[&#x27;parentmsg&#x27;],//将父组件传递过来的属性在props数组中定义一下才能使用该数据 &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-传递方法可以让子组件向父组件传值（使用-v-on）"><a href="#2-传递方法可以让子组件向父组件传值（使用-v-on）" class="headerlink" title="2.传递方法可以让子组件向父组件传值（使用 v-on）"></a>2.传递方法可以让子组件向父组件传值（使用 v-on）</h5><p>实质：$emit()子组件向父组件传参</p>
<p>使用自定义事件的系统来解决这个问题。父级组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += 0.1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时子组件可以通过调用内建的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-emit"><strong>$emit</strong> 方法</a> 并传入事件名称来触发一个事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span>Enlarge text<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有了这个 <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> 监听器，父级组件就会接收该事件并更新 <code>postFontSize</code> 的值。</p>
<p><code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 <code>$emit</code> 的第二个参数来提供这个值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//子组件 <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span>Enlarge text<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后当在父级组件监听这个事件的时候，我们可以通过 <code>$event</code> 访问到被抛出的这个值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += $event&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>如果这个事件处理函数是一个方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">...</span> <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;onEnlargeText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么这个值将会作为第一个参数传入这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="attr">onEnlargeText</span>: <span class="function"><span class="keyword">function</span> (<span class="params">enlargeAmount</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.postFontSize += enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="VUE-计算属性"><a href="#VUE-计算属性" class="headerlink" title="VUE 计算属性"></a>VUE 计算属性</h1><p><strong>计算属性与绑定方法的区别：计算属性具有缓存，只有相关依赖发生变化，才会重新进行求值。绑定方法则是在每次渲染都重新进行计算，当计算量大时，可以避免重新运算</strong></p>
<p><strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。</p>
<p>tip：侦听属性：watch</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">   <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">   <span class="attr">question</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.answer = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span><br><span class="line">     <span class="built_in">this</span>.debouncedGetAnswer()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue-的类切换"><a href="#vue-的类切换" class="headerlink" title="vue 的类切换"></a>vue 的类切换</h2><p><strong>对象语法</strong></p>
<p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class</p>
<p>绑定的数据对象不必内联定义在模板里：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data: &#123; classObject: &#123; active: true, &#x27;text-danger&#x27;: false &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组语法</strong></p>
<p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data: &#123; activeClass: &#x27;active&#x27;, errorClass: &#x27;text-danger&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>渲染为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据条件切换列表中的 class，可以用三元表达式</p>
<p><strong>在数组语法中也可以使用对象语法：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="VUE-的-set-解决检测数组变动的问题"><a href="#VUE-的-set-解决检测数组变动的问题" class="headerlink" title="VUE 的$set 解决检测数组变动的问题"></a>VUE 的$set 解决检测数组变动的问题</h3><p><strong>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</strong></p>
<ol>
<li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将触发状态更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>

<p>你也可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-set"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>

<p>为了解决第二类问题，你可以使用 <code>splice</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h3 id="对象更改检测注意事项"><a href="#对象更改检测注意事项" class="headerlink" title="对象更改检测注意事项"></a>对象更改检测注意事项</h3><p>还是由于 JavaScript 的限制，<strong>Vue 不能检测对象属性的添加或删除</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// `vm.a` 现在是响应式的</span><br><span class="line"></span><br><span class="line">vm.b = 2</span><br><span class="line">// `vm.b` 不是响应式的</span><br></pre></td></tr></table></figure>

<p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式属性。例如，对于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: &#x27;Anika&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你可以添加一个新的 <code>age</code> 属性到嵌套的 <code>userProfile</code> 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.userProfile, &#x27;age&#x27;, 27)</span><br></pre></td></tr></table></figure>

<p>你还可以使用 <code>vm.$set</code> 实例方法，它只是全局 <code>Vue.set</code> 的别名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.userProfile, &#x27;age&#x27;, 27)</span><br></pre></td></tr></table></figure>

<p>有时你可能需要为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(vm.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &#x27;Vue Green&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你应该这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &#x27;Vue Green&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="显示数组过滤-排序-副本"><a href="#显示数组过滤-排序-副本" class="headerlink" title="显示数组过滤/排序 副本"></a>显示数组过滤/排序 副本</h2><p>我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。</p>
<p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个 method 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;n in even(numbers)&quot;</span>&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  <span class="attr">numbers</span>: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">even</span>: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="VUE-事件"><a href="#VUE-事件" class="headerlink" title="VUE 事件"></a>VUE 事件</h1><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><p>  <code>.stop</code></p>
</li>
<li><p>  <code>.prevent</code></p>
</li>
<li><p>  <code>.capture</code></p>
</li>
<li><p>  <code>.self</code></p>
</li>
<li><p>  <code>.once </code> 只触发一次</p>
</li>
<li><p><code>.passive</code> Vue 还对应 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>  这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p>
</li>
<li><p>```HTML</p>
  <!-- 阻止单击事件继续传播 -->
<p>  <a v-on:click.stop="doThis"></a></p>
  <!-- 提交事件不再重载页面 -->
  <form v-on:submit.prevent="onSubmit"></form>

  <!-- 修饰符可以串联 -->
<p>  <a v-on:click.stop.prevent="doThat"></a></p>
  <!-- 只有修饰符 -->
  <form v-on:submit.prevent></form>

  <!-- 添加事件监听器时使用事件捕获模式 -->
  <!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 -->
  <div v-on:click.capture="doThis">...</div>

  <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
  <!-- 即事件不是从内部元素触发的 -->
  <div v-on:click.self="doThat">...</div>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**TIP:**使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**，而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。</span><br><span class="line"></span><br><span class="line">#### VUE 的按键修饰符：监听固定按键</span><br><span class="line"></span><br><span class="line">**监听固定按键**</span><br><span class="line"></span><br><span class="line">-   #### `.enter`</span><br><span class="line"></span><br><span class="line">-   `.tab`</span><br><span class="line"></span><br><span class="line">-   `.delete` (捕获“删除”和“退格”键)</span><br><span class="line"></span><br><span class="line">-   `.esc`</span><br><span class="line"></span><br><span class="line">-   `.space`</span><br><span class="line"></span><br><span class="line">-   `.up`</span><br><span class="line"></span><br><span class="line">-   `.down`</span><br><span class="line"></span><br><span class="line">-   `.left`</span><br><span class="line"></span><br><span class="line">-   `.right`</span><br><span class="line"></span><br><span class="line">也可使用键盘码</span><br><span class="line"></span><br><span class="line">**自定义全局按键修饰符的方法**</span><br><span class="line"></span><br><span class="line">Vue.config.keyCodes.f2 = 113;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
//@keyup.enter="add()"
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># VUE 动画和过渡</span><br><span class="line"></span><br><span class="line">Vue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</span><br><span class="line"></span><br><span class="line">-   条件渲染 (使用 `v-if`)</span><br><span class="line">-   条件展示 (使用 `v-show`)</span><br><span class="line">-   动态组件</span><br><span class="line">-   组件根节点</span><br><span class="line"></span><br><span class="line">这里是一个典型的例子：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt;</span><br><span class="line">    &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">        &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">show</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter-active</span>,</span><br><span class="line"><span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: opacity <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> <span class="comment">/* .fade-leave-active below version 2.1.8 */</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="VUE-混入"><a href="#VUE-混入" class="headerlink" title="VUE 混入"></a>VUE 混入</h1><h1 id="VUE-渲染函数"><a href="#VUE-渲染函数" class="headerlink" title="VUE 渲染函数"></a>VUE 渲染函数</h1><ol>
<li>render 方法的实质就是生成 template 模板；</li>
<li>通过调用一个方法来生成，而这个方法是通过 render 方法的参数传递给它的；</li>
<li>这个方法有三个参数，分别提供标签名，标签相关属性，标签内部的 html 内容</li>
<li>通过这三个参数，可以生成一个完整的木模板</li>
</ol>
<h3 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h3><p>虚拟 dom 不是真正意义上的 DOM，而是一个轻量级的 JavaScript 对象，在状态发生变化时，虚拟 dom 会进行 diff 运算，来更新只需要被替换的 DOM，而不是全部重绘</p>
<p>VNode 主要分为</p>
<p>TextVNode 文本节点</p>
<p>ELementVNode 普通元素节点</p>
<p>ComponentVNode 组件节点</p>
<p>EmptyVNode 没有内容的注释节点</p>
<p>CloneVNode 克隆节点，可以是以上任意类型的节点，唯一的区别在于 isCloned 属性为 true</p>
<p>Vue 通过建立一个<strong>虚拟 DOM</strong> 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return createElement(&#x27;h1&#x27;, this.blogTitle)</span><br></pre></td></tr></table></figure>

<p><code>createElement</code> 到底会返回什么呢？其实不是一个<em>实际的</em> DOM 元素。它更准确的名字可能是 <code>createNodeDescription</code>，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“<strong>VNode</strong>”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">createElement(</span><br><span class="line">    <span class="comment">// &#123;String | Object | Function&#125;</span></span><br><span class="line">    <span class="comment">// 一个 HTML 标签名、组件选项对象，或者</span></span><br><span class="line">    <span class="comment">// resolve 了上述任何一种的一个 async 函数。必填项。</span></span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#123;Object&#125;</span></span><br><span class="line">    <span class="comment">// 一个与模板中属性对应的数据对象。可选。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// (详情见下一节)</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#123;String | Array&#125;</span></span><br><span class="line">    <span class="comment">// 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，</span></span><br><span class="line">    <span class="comment">// 也可以使用字符串来生成“文本虚拟节点”。可选。</span></span><br><span class="line">    [</span><br><span class="line">        <span class="string">&#x27;先写一些文字&#x27;</span>,</span><br><span class="line">        createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;一则头条&#x27;</span>),</span><br><span class="line">        createElement(MyComponent, &#123;</span><br><span class="line">            <span class="attr">props</span>: &#123;</span><br><span class="line">                <span class="attr">someProp</span>: <span class="string">&#x27;foobar&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>渲染函数里的 v-model</p>
<p>jsx</p>
<h1 id="虚拟-dom-详解（转）"><a href="#虚拟-dom-详解（转）" class="headerlink" title="虚拟 dom 详解（转）"></a>虚拟 dom 详解（转）</h1><h4 id="一、真实-DOM-和其解析流程？"><a href="#一、真实-DOM-和其解析流程？" class="headerlink" title="一、真实 DOM 和其解析流程？"></a>一、真实 DOM 和其解析流程？</h4><p>​ 浏览器渲染引擎工作流程都差不多，大致分为 5 步，<strong>创建 DOM 树——创建 StyleRules——创建 Render 树——布局 Layout——绘制 Painting</strong></p>
<p>​ 第一步，用 HTML 分析器，分析 HTML 元素，<strong>构建一颗 DOM 树</strong>(标记化和树构建)。</p>
<p>​ 第二步，用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p>
<p>​ 第三步，将 DOM 树和样式表，关联起来，构建一颗 Render 树(这一过程又称为 Attachment)。每个 DOM 节点都有<strong>attach 方法，接受样式信息</strong>，返回一个 render 对象(又名 renderer)。这些 render 对象最终会被构建成一颗 Render 树。</p>
<p>​ 第四步，有了 Render 树，浏览器开始布局，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标。</p>
<p>​ 第五步，Render 树和节点显示坐标都有了，就调用每个节点<strong>paint 方法，把它们绘制</strong>出来。</p>
<p>​ <strong>DOM 树的构建是文档加载完成开始的？</strong>构建 DOM 数是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。<strong>它不必</strong>等到整个 HTML 文档解析完毕之后才开始构建 render 数和布局。</p>
<p>​ <strong>Render 树是 DOM 树和 CSSOM 树构建完毕才开始构建的吗？</strong>这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一遍解析，一遍渲染的工作现象。</p>
<p>​ <strong>CSS 的解析是从右往左逆向解析的</strong>(从 DOM 树的下－上解析比上－下解析效率高)，<strong>嵌套标签越多，解析越慢。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-b7ccad3bc808783f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/624/format/webp" alt="img"></p>
<p>webkit 渲染引擎工作流程</p>
<h4 id="二、JS-操作真实-DOM-的代价！"><a href="#二、JS-操作真实-DOM-的代价！" class="headerlink" title="二、JS 操作真实 DOM 的代价！"></a>二、JS 操作真实 DOM 的代价！</h4><p>​ 用我们传统的开发模式，原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行 10 次。例如，第一次计算完，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。</p>
<h4 id="三、为什么需要虚拟-DOM，它有什么好处"><a href="#三、为什么需要虚拟-DOM，它有什么好处" class="headerlink" title="三、为什么需要虚拟 DOM，它有什么好处?"></a>三、为什么需要虚拟 DOM，它有什么好处?</h4><p>​ Web 界面由 DOM 树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个 DOM 节点发生了变化，</p>
<p>​ 虚拟 DOM 就是为了<strong>解决浏览器性能问题</strong>而被设计出来的。<strong>如前</strong>，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量。<strong>所以，</strong>用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM)上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。</p>
<h4 id="四、实现虚拟-DOM"><a href="#四、实现虚拟-DOM" class="headerlink" title="四、实现虚拟 DOM"></a>四、实现虚拟 DOM</h4><p>​ 例如一个真实的 DOM 节点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-12f4a7f96b346deb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620/format/webp" alt="img"></p>
<p>真实 DOM</p>
<p>​ 我们用 JS 来模拟 DOM 节点实现虚拟 DOM。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-9aa021f6e7dc88fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/621/format/webp" alt="img"></p>
<p>虚拟 DOM</p>
<p>​ 其中的 Element 方法具体怎么实现的呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-9a6ae2a0e3a4c776.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/616/format/webp" alt="img"></p>
<p>Element 方法实现</p>
<p>​ 第一个参数是节点名（如 div），第二个参数是节点的属性（如 class），第三个参数是子节点（如 ul 的 li）。除了这三个参数会被保存在对象上外，还保存了<strong>key 和 count</strong>。其相当于形成了虚拟 DOM 树。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-1486296905180b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/712/format/webp" alt="img"></p>
<p>虚拟 DOM 树</p>
<p>​ 有了 JS 对象后，最终还需要将其映射成真实 DOM</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-a7d98ba2e9fb1bdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/616/format/webp" alt="img"></p>
<p>虚拟 DOM 对象映射成真实 DOM</p>
<p>​ 我们已经完成了创建虚拟 DOM 并将其映射成真实 DOM，这样所有的更新都可以先反应到虚拟 DOM 上，如何反应？需要用到<strong>Diff 算法</strong>。</p>
<p>​ 两棵树如果完全比较时间复杂度是 O(n^3)，但参照《深入浅出 React 和 Redux》一书中的介绍，React 的 Diff 算法的时间复杂度是 O(n)。要实现这么低的时间复杂度，意味着只能平层的比较两棵树的节点，放弃了深度遍历。这样做，似乎牺牲掉了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层移动 DOM 元素，这样做是最优的。</p>
<h4 id="深度优先遍历，记录差异"><a href="#深度优先遍历，记录差异" class="headerlink" title="深度优先遍历，记录差异"></a>深度优先遍历，记录差异</h4><p>​ 。。。。</p>
<h4 id="Diff-操作"><a href="#Diff-操作" class="headerlink" title="Diff 操作"></a>Diff 操作</h4><p>​ 在实际代码中，会对新旧两棵树进行一个深度的遍历，每个节点都会有一个标记。每遍历到一个节点就把该节点和新的树进行对比，如果有差异就记录到一个对象中。</p>
<p>​ 下面我们创建一棵新树，用于和之前的树进行比较，来看看 Diff 算法是怎么操作的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-58f905e4f9049b2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/621/format/webp" alt="img"></p>
<p>old Tree</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-e3aeff752058cd96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620/format/webp" alt="img"></p>
<p>new Tree</p>
<p>​ 平层 Diff，只有以下 4 种情况：</p>
<p>​ 1、<strong>节点类型变了</strong>，例如下图中的 P 变成了 H3。我们将这个过程称之为<strong>REPLACE</strong>。直接将旧节点卸载并装载新节点。旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做效率不高。但为了避免 O(n^3)的时间复杂度，这样是值得的。这也提醒了开发者，应该避免无谓的节点类型的变化，例如运行时将 div 变成 p 没有意义。</p>
<p>​ 2、<strong>节点类型一样，仅仅属性或属性值变了。</strong>我们将这个过程称之为<strong>PROPS</strong>。此时不会触发节点卸载和装载，而是节点更新。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-6b717c34619c54b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620/format/webp" alt="img"></p>
<p>查找不同属性方法</p>
<p>​ 3、<strong>文本变了</strong>，文本对也是一个 Text Node，也比较简单，直接修改文字内容就行了，我们将这个过程称之为<strong>TEXT</strong>。</p>
<p>​ 4、移动／增加／删除 子节点，我们将这个过程称之为<strong>REORDER</strong>。看一个例子，在 A、B、C、D、E 五个节点的 B 和 C 中的 BC 两个节点中间加入一个 F 节点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-4515ca8e797224a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp" alt="img"></p>
<p>例子</p>
<p>​ 我们<strong>简单粗暴的做法</strong>是遍历每一个新虚拟 DOM 的节点，与旧虚拟 DOM 对比相应节点对比，在旧 DOM 中是否存在，不同就卸载原来的按上新的。这样会对 F 后边每一个节点进行操作。卸载 C，装载 F，卸载 D，装载 C，卸载 E，装载 D，装载 E。<strong>效率太低。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-eb3f73c67d3ef57e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp" alt="img"></p>
<p>粗暴做法</p>
<p>​ 如果我们在 JSX 里为数组或枚举型元素增加上 key 后，它能够根据 key，直接找到具体位置进行操作，效率比较高。常见的<strong>最小编辑距离问题</strong>，可以用 Levenshtein Distance 算法来实现，时间复杂度是 O(M*N)，但通常我们只要一些简单的移动就能满足需要，降低精确性，将时间复杂度降低到 O(max(M,N))即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-ec9c6737f4e4f1da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/622/format/webp" alt="img"></p>
<p>最终 Diff 出来的结果</p>
<h4 id="映射成真实-DOM"><a href="#映射成真实-DOM" class="headerlink" title="映射成真实 DOM"></a>映射成真实 DOM</h4><p>​ 虚拟 DOM 有了，Diff 也有了，现在就可以将 Diff 应用到真实 DOM 上了。深度遍历 DOM 将 Diff 的内容更新进去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-73e7e6db57d95032.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/617/format/webp" alt="img"></p>
<p>根据 Diff 更新 DOM</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345378-424038129a2f06f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/617/format/webp" alt="img"></p>
<p>根据 Diff 更新 DOM</p>
<p>我们会有两个虚拟 DOM(js 对象，new/old 进行比较 diff)，用户交互我们操作数据变化 new 虚拟 DOM，old 虚拟 DOM 会映射成<strong>实际 DOM(<strong>js 对象生成的 DOM 文档)通过</strong>DOM fragment</strong>操作给浏览器渲染。当修改 new 虚拟 DOM，会把 newDOM 和 oldDOM 通过 diff 算法比较，得出 diff 结果数据表(用 4 种变换情况表示)。再把 diff 结果表通过<strong>DOM</strong> <strong>fragment</strong>更新到<strong>浏览器 DOM</strong>中。</p>
<p>虚拟 DOM 的存在的意义？vdom 的真正意义是为了实现跨平台，服务端渲染，以及提供一个性能还算不错 Dom 更新策略。vdom 让整个 mvvm 框架灵活了起来</p>
<p>Diff 算法只是为了虚拟 DOM 比较替换效率更高，通过 Diff 算法得到 diff 算法结果数据表(需要进行哪些操作记录表)。原本要操作的 DOM 在 vue 这边还是要操作的，只不过用到了 js 的<strong>DOM</strong> <strong>fragment</strong>来操作 dom（统一计算出所有变化后统一更新一次 DOM）进行浏览器 DOM 一次性更新。其实<strong>DOM</strong> <strong>fragment</strong>我们不用平时发开也能用，但是这样程序员写业务代码就用把 DOM 操作放到 fragment 里，这就是框架的价值，程序员才能专注于写业务代码<strong>。</strong></p>
<h1 id="VUE-过滤器"><a href="#VUE-过滤器" class="headerlink" title="VUE 过滤器"></a>VUE 过滤器</h1><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 v-bind 表达式</strong> (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“<strong>管道”符号</strong>指示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="webpack-学习"><a href="#webpack-学习" class="headerlink" title="webpack 学习"></a>webpack 学习</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">//导入插件</span></span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: <span class="string">&#x27;./main.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>), <span class="comment">//输出的路径</span></span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/dist/&#x27;</span>, <span class="comment">//资源文件引用的目录</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>, <span class="comment">//输出文件的名称</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//模块配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">//指定loader，每一个lodaer必须包含test和use两个选项</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                    <span class="attr">use</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">fallback</span>: <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                &#125;),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//插件配置</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">//重命名提取后的css文件</span></span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">&#x27;main.css&#x27;</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure>

<p>入口</p>
<p>出口</p>
<p>加载器</p>
<p>vue-loader</p>
<p>vue-style-loader</p>
<p>babel-loader</p>
<p>…</p>
<p>插件</p>
<p><strong>箭头函数体内的 this 对象就是定义时所在的对象，而不是使用时所在的对象</strong></p>
<p><strong>对象字面量可以缩写，当对象的 key 和 value 名称一致时，可以缩写成一个</strong></p>
<h1 id="SPA-单页面应用部署过程："><a href="#SPA-单页面应用部署过程：" class="headerlink" title="SPA 单页面应用部署过程："></a>SPA 单页面应用部署过程：</h1><p>SPA 只有一个 html 文件，一般将该 html’挂在后端程序下，由后端路由渲染这个页面，将所有的静态资源（css,js,image,iconfont 等）单独部署到 CDN，当然也可以和后端程序部署在一起，实现前后端完全分离</p>
<h1 id="VUE-插件"><a href="#VUE-插件" class="headerlink" title="VUE 插件"></a>VUE 插件</h1><p>通过<code>install</code>注册插件，通过<code>Vue.use()</code>使用插件</p>
<p>vue 的核心插件 vue-router、vuex</p>
<h2 id="vue-router-路由"><a href="#vue-router-路由" class="headerlink" title="vue-router 路由"></a>vue-router 路由</h2><p>什么是路由？通俗的讲就是网址，专业的讲：每次 GET 或 POST 等请求在服务端会有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的 Controller，进行操作，最终将 html 或数据返回给前端，完成了一次 IO</p>
<p>前端路由</p>
<p>优点：页面持久性，如音乐网站切换音乐不会中断；前后端完全分离</p>
<p>缺点：需要加载 css 和 js</p>
<p>后端路由</p>
<p>优点：seo 优化好，不需要等待前端加载</p>
<p>缺点：单独由后端维护，前端要修改模板需安装整套后端服务，前后端混杂，不易于分离</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/20/%E5%88%9D%E5%85%A5%E5%89%8D%E7%AB%AF/2019.8.7sui/">2019.8.7sui</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%B5%B7%E6%AD%A5/">起步</a></span><div class="content"><p>今天想好好的认真开始维护自己的博客</p>
<p>记于 2019.8.7 sui</p>
<p>昨天晚上是我第一次面腾讯，其实当时投腾讯的时候就想着罢了罢了，反正啥也不会投着试试呗的心态，没想过腾讯居然会给我打面试电话。</p>
<p>可能真的神仙太强了招不到把，虽然腾讯给我打了电话，但我深知我现在的这种知识储备是绝对进不了腾讯的，所以就直接同面试官聊了起来，但是这个面试官似乎好像要加班赶业务。而且我投的是前端岗，面我的大哥居然是客户端开发的，头疼。</p>
<p>然后呢，问问我操作系统，我说我没学过不会，问我网络吧，知识太繁杂，看过但是忘了，唯一一个问我前端的问题是，JavaScript 的语言运行机制，当时答的还不错，那个面试官甚至发出了夸赞的声音，蛮自豪的，感觉自己对 JavaScript 的理解还是有点东西的。</p>
<p>最后呢，我觉得反正肯定过不了，就将就的答呗。</p>
<p>通过昨天的电面，我今天深刻的思考了一下，我目前仍存在的缺陷</p>
<p>对计算机基础还是非常薄弱的，操作系统，编译原理 ，计网，算法与数据结构全都是我的弱项</p>
<p>对原生 JavaScript 的一些字符串，数组，的 API 还不是特别的熟悉，目前只做到知道什么时候该使用这个 API，实际使用还是需要搜索一下，看一眼文档才能进行操作</p>
<p>对 JS 的设计模式知识空白，今天看了掘金的文档才对其有一个认知，设计模式在平常开发中是帮助很大的，很多时候我们开发已经在不知不觉中使用了设计模式，比如一些组件开发，涉及到一些逻辑的时候，如果有设计模式思想的指导，那么这些逻辑将很容易就实现，这个同数据结构是一样的，目前我就是做到，知道有这个东西，知道这个玩意在开发中可以用来干嘛，但是实际使用起来还是离不开文档，这也应该和我学习前端的时间长度有关，我还是需要一些时间去进行沉淀一下自己所学的东西</p>
<p>对 JS 的对象编程还不是特别熟悉，之前也是看过很多弄懂原型链啊、继承啊之类的文章，当时看的时候也写了一些小心得，但是这段时间在公司实习，过于专注于业务和工作流程的学习，发现自己对这些知识又有些疏生了</p>
<p>今日随笔突然被突如其来的业务需求打断，思路全没了，就到这里吧</p>
<p>T.T</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By liuarui</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>